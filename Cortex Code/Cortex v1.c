#pragma config(UART_Usage, UART1, uartUserControl, baudRate9600, IOPins, None, None)
#pragma config(UART_Usage, UART2, uartUserControl, baudRate9600, IOPins, None, None)
#pragma config(Motor,  port2,           leftFront,     tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port3,           leftBack,      tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port4,           rightFront,    tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           rightBack,     tmotorVex393HighSpeed_MC29, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX2)
#pragma competitionControl(Competition)
#include "Vex_Competition_Includes.c"

//***************************Set up misc****************************



//********************Consts and Varibles Decl**********************

const int deadZone = 15;
const char parseSep = "a";
int rx, ry, rz; 	// f/b, l/r, clw/aclw. For motor speed setting.
bool uart;					//which UART to use, true for 1, false for 2.
string out;				//data to send out of UART.
string dataIn1, dataIn2;	//data in from UART1/2 respectively.
bool sending;			//flag high when sending data out UART. True when sending data.
bool rec1, rec2;	//flags high when recieving data from UART1/2 respectively. Reset to low when data has been read.

//*******************End of Consts and Variables********************

//*******************Function & Tasks Decl**************************

task debug();
task SerialOut();
task SerialIn();

//********************End of Func & Tasks Decl**********************

//********************Start of Competition Code*********************
void pre_auton()
{
	bStopTasksBetweenModes = false;
}

task autonomous()
{
	startTask(debug);
	startTask(SerialIn);
	AutonomousCodePlaceholderForTesting();
}

task usercontrol()
{
	startTask(debug);
	startTask(SerialIn);
	while (true)
	{
		// deadzone
		if(abs(vexRT[Ch3]) >  deadZone)	{rx = vexRT[Ch3];} else {rx = 0;}
		if(abs(vexRT[Ch4]) >  deadZone) {ry = vexRT[Ch4];} else {ry = 0;}
		if(abs(vexRT[Ch1]) >  deadZone) {rz = vexRT[Ch1];} else {rz = 0;}

		// update motor speeds
		motor[rightFront] = rx - rz - ry;	motor[rightBack] = rx - rz + ry; motor[leftFront] = rx + rz + ry; motor[leftBack] = rx + rz - ry;
	}
}

//********************End of Competition Code***********************






//**********************Start of User Functions*********************

//**********************************************************************************************************************
//**********Debug sends data out to laptop via USB or VEXNET. Data is seperated by value of the const parseSep *********
//************************This task should be constantly running throughout all stages of the code**********************
//**********************************************************************************************************************
task debug()
{
	int speedFL, speedBL, speedFR, speedBR;
	speedBL = getMotorVelocity(leftBack);
	speedBR = getMotorVelocity(rightBack);
	speedFL = getMotorVelocity(leftFront);
	speedFR = getMotorVelocity(rightFront);
	writeDebugStream("a",parseSep,nAvgBatteryLevel,parseSep,speedBL,parseSep,speedBR,parseSep,speedFL,parseSep,speedFR,parseSep,bIfiAutonomousMode,parseSep,bIfiRobotDisabled,parseSep,bResetFromWatchdogTimeout,"b");
	wait10Msec(10);
}

//**********************************************************************************************************************
//****SerialOut send the string 'out' of the UART port specified by the bool 'uart' at the time of calling the task ****
//**The flag 'sending' is high when data is being send and low when not. The task should be called after updating 'out'*
//************************************and stopped when 'sending' is low again*******************************************
//**********************************************************************************************************************
task SerialOut()
{
	int legnth = strlen(out);
	sending = true;
	for(int i = 0; i < legnth; ++i)
	{
		if(uart) {sendChar(UART1, stringGetChar(out, i));} else {sendChar(UART2, stringGetChar(out, i));}
	}
	sending = false;
	stopTask(SerialOut);
}

//**********************************************************************************************************************
//***********SerialIn recieves data from UART 1 and UART2 into the trings dataIn2 and dataIn2 respectively.  ***********
//*****The flags rec1 & rec2 are high when the buffer has been emptied and should be reset to low when data has been****
//**************************processed to allow further data to be read from the buffer**********************************
//**********************************************************************************************************************
task SerialIn()
{
	while(true)
	{
		if(!rec1) {dataIn1 = "";}
		if(!rec2) {dataIn2 = "";}
		while(getChar(UART1) != -1 && !rec1)
		{
			dataIn1 = dataIn1 + getChar(UART1);
			rec1 = true;
		}
		while(getChar(UART2) != -1 && !rec2)
		{
			dataIn2 = dataIn2 + getChar(UART2);
			rec2 = true;
		}
		wait1Msec(10);
	}
}
